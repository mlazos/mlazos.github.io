<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

        <title>Mike Lazos - Notes on CallCC</title>

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" />
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">

        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/custom.css" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
            <div class="container-fluid">
                <div class="navbar-header">
                    <a class="navbar-brand" href="#">Mike Lazos</a>
                </div>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
                        <li><a href="../index.html">Home</a></li>
                        <li><a href="../about.html">About</a></li>
                        <li><a href="../projects.html">Projects</a></li>
                        <li><a href="../posts.html">Posts</a></li>
                        <li><a href="../readings.html">Reading List</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://github.com/mlazos"><i class="fa fa-github fa-lg fa-fw"></i></a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container">
            <div class="row">
                <div class="col-md-10 col-md-offset-1">
                    <div class="page-header">
    <h1>Notes on CallCC</h1>
    <small>Posted on September 16, 2021 <a href="../posts/2021-09-16-Notes-On-CallCC.html"><i class="fa fa-link fa-lg fa-fw"></i></a></small>
</div>

<h3 id="introduction-and-background">Introduction and Background</h3>
<p>These are my notes detailing my intuition of <code>callCC</code> (call-with-current-continuation) after reading through the <a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">continuation passing style chapter</a> of the Haskell wikibook. <code>callCC</code> is a control operator which enables explicit manipulation of a program’s control flow. In this post we will focus on the Haskell implementation - the <a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">continuation monad</a>, and provide some additional details not covered in the wikibooks chapter.</p>
<h3 id="callcc-in-haskell">CallCC in Haskell</h3>
<p>In Haskell, <code>callCC</code> is provided through the <code>Cont</code> monad. This monad enables computations to be transformed to/from <a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">continuation passing style</a>. This doesn’t enable much on its own, because the explicit control flow manipulation enabled by CPS is not exposed through the typical bind and return operators of the monad - these just enable construction and composition of a computation chain in CPS form. <code>callCC</code> however enables the programmer to explicitly manipulate this control flow, by binding the current continuation to an identifier and enabling the programmer to call this continuation anywhere in the program. To begin our investigation of <code>callCC</code> first let’s understand the relevant details of the <code>Cont</code> monad. The type signatures of the wrapper and unwrapper functions are important, because we will use them to access the relevant continuations in our implementation of <code>callCC</code>. Additionally the monadic bind shows how we apply a CPS function to a chain of suspended computations.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- A possible definition for Cont r a, record syntax defines a getter runCont :: Cont r a -&gt; (a -&gt; r) -&gt;  r</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">-- which can be used to extract a CPS function from a CPS computation</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">-- Create a CPS computation from a CPS function, the inverse of runCont</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">-- Cont r a describes a computation which needs a continuation of type (a -&gt; r) to conclude and return an r</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">cont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a </span>
<span id="cb1-8"><a href="#cb1-8"></a>cont f <span class="ot">=</span> <span class="dt">Cont</span> \k <span class="ot">-&gt;</span> f k <span class="co">-- k is the next continuation in the chain</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">-- Monadic bind provides a way of extending the computation chain with a CPS function</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="fu">return</span> x <span class="ot">=</span> cont (<span class="op">$</span> x)</span>
<span id="cb1-13"><a href="#cb1-13"></a>s <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> cont <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont s <span class="op">$</span> \x <span class="ot">-&gt;</span> runCont (f x) c <span class="co">-- Note: s is a suspended computation to be augmented with f</span></span></code></pre></div>
<p>Now let’s form our intuition before implementating the function. We know fundamentally that <code>callCC</code> takes a function <code>f</code> and provides the current continuation through a bound identifier within the scope of <code>f</code>. We also know that calling this continuation breaks the current computation chain, and jumps to the body of this continuation. The steps we need then, are the following:</p>
<ol type="1">
<li>Name the current continuation</li>
<li>Construct a new continuation which will unconditionally call the current continuation (ignoring the next continuation in the chain)</li>
<li>Provide this continuation as a function to <code>f</code> so that it can call it where desired to break out of the current chain of suspended computations</li>
<li>Ensure the current continuation will be called even if <code>f</code> doesn’t call the provided breaking function</li>
</ol>
<p>Step 4 is important to note, because the programmer also has the option of not calling the provided continuation, and continuing through the unmodified suspended computation chain. Now that we know the steps, let’s start implementing them, using the types to check our intuition. So with step 1, we need to access the current continuation. We know how to do this from the type signature of a CPS function, and from the CPS monadic bind. The current continuation is the <code>(a -&gt; r)</code> argument of a CPS function. This argument has not been provided yet, since each <code>Cont r a</code>, represents a suspended computation, which will complete when given a continuation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="op">...</span> </span></code></pre></div>
<p>This gives us access to the current continuation, <code>h</code>, which will be populated by either the next continuation in the chain, or by the continuation provided by <code>runCont</code>. This follows exactly the pattern from the monadic bind.</p>
<p>Now in step 2, we should create another continuation that will unconditionally call h, ignoring its provided continuation argument (the break in the chain that we alluded to above).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="op">...</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h <span class="op">...</span></span></code></pre></div>
<p>Now, we know that the type of h is <code>(a -&gt; r)</code> so we need to provide it with an argument. Where does this argument come from? Its caller, and we know that the “break in the chain” is called from within <code>f</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="op">...</span> f (\x <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h x) <span class="op">...</span></span></code></pre></div>
<p>As we mentioned previously <code>f</code> can either call or not call the breaking function. However, <code>f</code> must return the same type in both cases, namely <code>Cont r a</code>. From here, we need to ensure we pass <code>h</code> onto the continuation returned by <code>f</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont f (\x <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h x) h</span></code></pre></div>
<p>This is our final implementation. In essence, we provide <code>h</code> to <code>f</code> through a function which will unconditionally call <code>h</code>, and if <code>f</code> does not call that function, the outer <code>runCont</code> will provide <code>h</code> as the next continuation after the continuation chain within <code>f</code> has completed. Now that we have a full implementation, let’s analyze its type.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">callCC ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span></code></pre></div>
<p>This type looks complex, but on closer examination, it is not unexpected from what we know of our implementation steps. First, the return value of <code>Cont r a</code> is exactly as we expect, since <code>callCC</code> returns a newly created <code>Cont r a</code>. The type of <code>f</code> is <code>((a -&gt; Cont r b) -&gt; Cont r a)</code> indicating that <code>f</code> takes a function <code>(a -&gt; Cont r b)</code> (our function to beak the continuation chain) and returns a <code>Cont r a</code>. What is interesting here is that <code>b</code> is an arbitrary type. This stems from the return type of <code>(\x -&gt; cont $ \_ -&gt; h x)</code>. Since the continuation which is returned ignores its argument and unconditionally invokes <code>h</code>, and because the <code>b</code> in <code>Cont r b</code> represents the argument type of the continuation, this type <code>b</code> is not constrained.</p>
<h3 id="extensions">Extensions</h3>
<ul>
<li>Implement <code>callCC</code> without using monads (hint: take a look at <code>chainCPS</code> in the wikibook chapter)</li>
<li>What happens if the breaking function is called later in a computation (for instance by storing it in the <code>Reader</code> monad)</li>
<li>What are the performance implications of a function like <code>callCC</code>?</li>
</ul>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    tags: 'ams'
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
                </div>
            </div>
        </div>
</body>
</html>
